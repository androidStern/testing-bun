import Typesense from 'typesense'
import type Client from 'typesense/lib/Typesense/Client'
import type { CollectionCreateSchema } from 'typesense/lib/Typesense/Collections'
import type { SnagajobJob } from '../scrapers/snagajob'
import type { TransitScore } from '../transit-scorer'
import type { SecondChanceScore } from './enrichment/second-chance-scorer'
import type { ShiftResult } from './enrichment/shift-extractor'

let client: Client | null = null

export function getTypesense(): Client {
  if (!client) {
    const typesenseUrl = process.env.TYPESENSE_URL
    const apiKey = process.env.TYPESENSE_API_KEY

    if (!typesenseUrl) {
      throw new Error('TYPESENSE_URL environment variable is required')
    }
    if (!apiKey) {
      throw new Error('TYPESENSE_API_KEY environment variable is required')
    }

    const url = new URL(typesenseUrl)
    client = new Typesense.Client({
      apiKey,
      connectionTimeoutSeconds: 10,
      nodes: [
        {
          host: url.hostname,
          port: parseInt(url.port) || 8108,
          protocol: url.protocol.replace(':', '') as 'http' | 'https',
        },
      ],
    })
  }
  return client
}

export const JOBS_COLLECTION = 'jobs'

export const jobsSchema: CollectionCreateSchema = {
  default_sorting_field: 'posted_at',
  fields: [
    { name: 'id', type: 'string' },
    { name: 'external_id', type: 'string' },
    { facet: true, name: 'source', type: 'string' },
    { name: 'title', type: 'string' },
    { facet: true, name: 'company', type: 'string' },
    { name: 'description', optional: true, type: 'string' },

    // Semantic search embedding (auto-generated by Typesense via OpenAI)
    {
      embed: {
        from: ['title', 'description'],
        model_config: {
          api_key: process.env.OPENAI_API_KEY!,
          model_name: 'openai/text-embedding-3-small',
        },
      },
      name: 'embedding',
      optional: true,
      type: 'float[]',
    },

    { name: 'location', optional: true, type: 'geopoint' },
    { facet: true, name: 'city', optional: true, type: 'string' },
    { facet: true, name: 'state', optional: true, type: 'string' },
    { name: 'salary_min', optional: true, type: 'int32' },
    { name: 'salary_max', optional: true, type: 'int32' },
    { name: 'salary_type', optional: true, type: 'string' },

    // Transit (from existing transit-scorer.ts)
    { name: 'transit_score', optional: true, type: 'int32' },
    { name: 'transit_distance', optional: true, type: 'float' },
    { facet: true, name: 'bus_accessible', optional: true, type: 'bool' },
    { facet: true, name: 'rail_accessible', optional: true, type: 'bool' },

    // Recovery-specific enrichment
    { facet: true, name: 'shift_morning', optional: true, type: 'bool' },
    { facet: true, name: 'shift_afternoon', optional: true, type: 'bool' },
    { facet: true, name: 'shift_evening', optional: true, type: 'bool' },
    { facet: true, name: 'shift_overnight', optional: true, type: 'bool' },
    { facet: true, name: 'shift_flexible', optional: true, type: 'bool' },
    { facet: true, name: 'second_chance', optional: true, type: 'bool' },
    { name: 'second_chance_score', optional: true, type: 'int32' },
    { facet: true, name: 'second_chance_tier', optional: true, type: 'string' },
    { name: 'second_chance_confidence', optional: true, type: 'float' },

    // Job metadata
    { facet: true, name: 'job_type', optional: true, type: 'string' },
    { facet: true, name: 'is_urgent', optional: true, type: 'bool' },
    { facet: true, name: 'is_easy_apply', optional: true, type: 'bool' },
    { name: 'url', type: 'string' },
    { name: 'posted_at', type: 'int64' },
  ],
  name: JOBS_COLLECTION,
}

export async function ensureJobsCollection(): Promise<void> {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OPENAI_API_KEY environment variable is required for embedding generation')
  }

  const typesense = getTypesense()

  try {
    await typesense.collections(JOBS_COLLECTION).retrieve()
    console.log("[Typesense] Collection 'jobs' exists")
  } catch (err: any) {
    if (err?.httpStatus === 404) {
      console.log("[Typesense] Creating 'jobs' collection...")
      await typesense.collections().create(jobsSchema)
      console.log('[Typesense] Collection created')
    } else {
      throw err
    }
  }
}

export interface EnrichedJob extends SnagajobJob {
  transit?: TransitScore
  shifts?: ShiftResult
  secondChanceScore?: SecondChanceScore
}

export interface TypesenseJobDocument {
  id: string
  external_id: string
  source: string
  title: string
  company: string
  description?: string
  location?: [number, number] // [lat, lng]
  city?: string
  state?: string
  salary_min?: number
  salary_max?: number
  salary_type?: string
  transit_score?: number
  transit_distance?: number
  bus_accessible?: boolean
  rail_accessible?: boolean
  shift_morning?: boolean
  shift_afternoon?: boolean
  shift_evening?: boolean
  shift_overnight?: boolean
  shift_flexible?: boolean
  second_chance?: boolean
  second_chance_score?: number
  second_chance_tier?: string
  second_chance_confidence?: number
  job_type?: string
  is_urgent?: boolean
  is_easy_apply?: boolean
  url: string
  posted_at: number
}

export function toTypesenseDocument(
  job: EnrichedJob,
  source: string = 'snagajob',
): TypesenseJobDocument {
  const doc: TypesenseJobDocument = {
    company: job.company,
    external_id: job.id,
    id: `${source}-${job.id}`,
    posted_at: job.postedDate ? new Date(job.postedDate).getTime() : Date.now(),
    source,
    title: job.title,
    url: job.applyUrl || '',
  }

  // Location
  if (job.latitude && job.longitude) {
    doc.location = [job.latitude, job.longitude]
  }
  if (job.city) doc.city = job.city
  if (job.state) doc.state = job.state

  // Description
  if (job.descriptionText) {
    doc.description = job.descriptionText.substring(0, 10000) // Truncate long descriptions
  }

  // Salary
  if (job.payMin) doc.salary_min = Math.round(job.payMin)
  if (job.payMax) doc.salary_max = Math.round(job.payMax)
  if (job.payType) {
    // payType from snagajob API is numeric (1=hourly, etc)
    const payTypeMap: Record<string | number, string> = {
      1: 'hourly',
      2: 'salary',
      3: 'daily',
      daily: 'daily',
      hourly: 'hourly',
      salary: 'salary',
    }
    doc.salary_type = payTypeMap[job.payType] || String(job.payType)
  }

  // Transit enrichment
  if (job.transit) {
    // Convert letter grade to numeric score (0-100)
    const scoreMap: Record<string, number> = {
      A: 85,
      'A+': 100,
      B: 70,
      C: 50,
      D: 25,
    }
    doc.transit_score = scoreMap[job.transit.score] ?? 0
    doc.transit_distance = job.transit.distanceMiles
    doc.bus_accessible = !job.transit.nearbyRail && job.transit.nearbyStops > 0
    doc.rail_accessible = job.transit.nearbyRail
  }

  // Shift enrichment
  if (job.shifts) {
    doc.shift_morning = job.shifts.morning
    doc.shift_afternoon = job.shifts.afternoon
    doc.shift_evening = job.shifts.evening
    doc.shift_overnight = job.shifts.overnight
    doc.shift_flexible = job.shifts.flexible
  }

  // Second chance enrichment (multi-signal scoring)
  if (job.secondChanceScore) {
    doc.second_chance_score = job.secondChanceScore.score
    doc.second_chance_tier = job.secondChanceScore.tier
    doc.second_chance_confidence = job.secondChanceScore.confidence
    // Derive legacy boolean from tier for backwards compatibility
    doc.second_chance =
      job.secondChanceScore.tier === 'high' || job.secondChanceScore.tier === 'medium'
  }

  // Job metadata
  if (job.jobType) doc.job_type = job.jobType
  doc.is_urgent = job.isUrgent
  doc.is_easy_apply = job.isEasyApply

  return doc
}

export async function indexJob(job: EnrichedJob, source: string = 'snagajob'): Promise<void> {
  const typesense = getTypesense()
  const doc = toTypesenseDocument(job, source)
  await typesense.collections(JOBS_COLLECTION).documents().upsert(doc)
}

export async function indexJobs(
  jobs: EnrichedJob[],
  source: string = 'snagajob',
): Promise<{ success: number; failed: number }> {
  const typesense = getTypesense()
  const docs = jobs.map(job => toTypesenseDocument(job, source))

  const results = await typesense
    .collections(JOBS_COLLECTION)
    .documents()
    .import(docs, { action: 'upsert' })

  let success = 0
  let failed = 0

  for (const result of results) {
    if (result.success) {
      success++
    } else {
      failed++
      console.error('[Typesense] Failed to index job:', result.error)
    }
  }

  // Throw if ALL jobs failed to index - indicates a systemic problem
  if (failed > 0 && failed === results.length) {
    throw new Error(`All ${failed} jobs failed to index to Typesense`)
  }

  return { failed, success }
}

/**
 * Delete a single job from Typesense by its document ID
 * Document ID format: `${source}-${externalId}`
 */
export async function deleteJobDocument(typesenseId: string): Promise<void> {
  const typesense = getTypesense()
  await typesense.collections(JOBS_COLLECTION).documents(typesenseId).delete()
  console.log(`[Typesense] Deleted job: ${typesenseId}`)
}

/**
 * Delete multiple jobs from Typesense
 * Returns counts of successful and failed deletions
 */
export async function deleteJobDocuments(
  typesenseIds: string[],
): Promise<{ success: number; failed: number; errors: string[] }> {
  const typesense = getTypesense()
  let success = 0
  let failed = 0
  const errors: string[] = []

  for (const id of typesenseIds) {
    try {
      await typesense.collections(JOBS_COLLECTION).documents(id).delete()
      success++
    } catch (err: any) {
      if (err?.httpStatus === 404) {
        // Already deleted, count as success
        success++
      } else {
        failed++
        errors.push(`${id}: ${err.message}`)
      }
    }
  }

  console.log(`[Typesense] Deleted ${success}/${typesenseIds.length} jobs`)
  return { errors, failed, success }
}
